/*
Copyright 2024 Massimo Fioravanti

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#pragma once

#include <variant>

#include "llvm/ADT/ArrayRef.h"
#include "mlir/IR/OpImplementation.h"
#include "mlir/IR/Operation.h"
#include "mlir/IR/SymbolTable.h"
#include "mlir/IR/TypeRange.h"
#include "mlir/Interfaces/CallInterfaces.h"
#include "mlir/Interfaces/SideEffectInterfaces.h"
#include "rlc/dialect/Attrs.hpp"
#include "rlc/dialect/Enums.hpp"
#include "rlc/dialect/Interfaces.hpp"
#include "rlc/dialect/OverloadResolver.hpp"
#include "rlc/dialect/Types.hpp"

namespace mlir::rlc::detail
{

	mlir::rlc::ActionFunction typeCheckAction(
			mlir::rlc::ActionFunction fun, ValueTable* parentSymbolTable = nullptr);

	template<typename Op>
	mlir::LogicalResult handleBuiltin(
			Op op,
			mlir::IRRewriter& rewriter,
			mlir::Type expectedType,
			mlir::Type resType = nullptr)
	{
		mlir::SmallVector<mlir::Type, 4> operandTypes;
		mlir::SmallVector<mlir::Value, 4> operandValue;
		for (mlir::OpOperand& t : op.getOperation()->getOpOperands())
		{
			operandTypes.push_back(t.get().getType());
			operandValue.push_back(t.get());
		}

		if (llvm::all_of(operandTypes, [expectedType](mlir::Type in) {
					return in == expectedType;
				}))
		{
			rewriter.replaceOpWithNewOp<Op>(
					op, resType != nullptr ? resType : expectedType, operandValue);
			return mlir::success();
		}
		return mlir::failure();
	}

	template<typename Op>
	mlir::LogicalResult typeCheckInteralOp(
			Op op,
			mlir::rlc::ModuleBuilder& builder,
			mlir::TypeRange accetableTypes,
			mlir::Type res = nullptr);

}	 // namespace mlir::rlc::detail

namespace mlir::rlc
{

	mlir::LogicalResult typeCheck(
			mlir::Operation& op, mlir::rlc::ModuleBuilder& builder);

	// mark a operation as being generated by the compiler instead of being
	// written in the source file so we know that we don't have to emit it when we
	// format the source file
	inline void markSynthetic(mlir::Operation* op)
	{
		op->setAttr("synthetic", mlir::UnitAttr::get(op->getContext()));
	}

	inline bool isSynthetic(mlir::Operation* op)
	{
		return op->hasAttr("synthetic");
	}

	struct ActionFrameContent
	{
		public:
		void append(mlir::Value value, llvm::StringRef name)
		{
			valueNamePairs.push_back(
					std::pair<mlir::Value, llvm::StringRef>(value, name));
		}
		size_t indexOf(mlir::Value val) const
		{
			auto* it = llvm::find_if(
					valueNamePairs,
					[val](const ValueNamePair& pair) { return pair.first == val; });
			assert(it != valueNamePairs.end());
			return std::distance(valueNamePairs.begin(), it);
		}
		using ValueNamePair = std::pair<mlir::Value, llvm::StringRef>;
		llvm::SmallVector<ValueNamePair, 4> valueNamePairs;
	};
}	 // namespace mlir::rlc

#define GET_OP_CLASSES
#include "rlc/dialect/Operations.inc"

namespace mlir::rlc
{

	template<typename T>
	inline std::string builtinOperatorName()
	{
		return T::getOperationName()
				.drop_front(mlir::rlc::RLCDialect::getDialectNamespace().size() + 1)
				.str();
	}

	mlir::LogicalResult emitImplicitAssign(
			mlir::ModuleOp op, mlir::rlc::ModuleBuilder& builder);
	void emitImplicitInits(mlir::ModuleOp op, mlir::rlc::ModuleBuilder& builder);
	void lowerIsOperations(mlir::Operation* op, mlir::rlc::ValueTable& table);
	void lowerConstructOps(
			mlir::rlc::ModuleBuilder& builder, mlir::Operation* op);
	void lowerAssignOps(mlir::rlc::ModuleBuilder& builder, mlir::Operation* op);

	void lowerForFields(mlir::rlc::ModuleBuilder& builder, mlir::Operation* op);

	void lowerDestructors(
			llvm::DenseMap<mlir::Type, bool>& requireDestructor,
			mlir::rlc::ModuleBuilder& builder,
			mlir::Operation* op);

}	 // namespace mlir::rlc

namespace mlir::rlc::detail
{
	static bool areArgsArrayAndCompatible(mlir::ValueRange args)
	{
		assert(not args.empty());
		if (not mlir::isa<mlir::rlc::ArrayType>((*args.begin()).getType()))
			return false;

		auto currentSize =
				mlir::cast<mlir::rlc::ArrayType>((*args.begin()).getType()).getSize();

		for (auto arg : llvm::drop_begin(args))
		{
			auto casted = mlir::dyn_cast<mlir::rlc::ArrayType>(arg.getType());
			if (casted == nullptr)
				return false;
			if (casted.getSize() != currentSize)
				return false;
		}

		return true;
	}

	template<typename Op>
	mlir::LogicalResult typeCheckInteralOp(
			Op op,
			mlir::rlc::ModuleBuilder& builder,
			mlir::TypeRange accetableTypes,
			mlir::Type resType)
	{
		auto& rewriter = builder.getRewriter();
		std::string opName = builtinOperatorName<Op>();

		mlir::SmallVector<mlir::Type, 4> operandTypes;
		mlir::SmallVector<mlir::Value, 4> operandValues;

		for (mlir::OpOperand& t : op.getOperation()->getOpOperands())
		{
			operandTypes.push_back(t.get().getType());
			operandValues.push_back(t.get());
		}

		if (llvm::any_of(operandTypes, [&](mlir::Type t) {
					return mlir::isa<mlir::rlc::UnknownType>(t);
				}))
		{
			op.emitError("argument op operation had unknown type");
			return mlir::failure();
		}

		// if it's builtin, early out
		for (auto type : accetableTypes)
			if (handleBuiltin(op, rewriter, type, resType).succeeded())
				return mlir::success();

		mlir::SmallVector<mlir::Type, 4> lookUpUperandTypes(operandTypes);

		mlir::rlc::OverloadResolver resolver(builder.getSymbolTable(), op);
		rewriter.setInsertionPoint(op);
		auto overload = resolver.instantiateOverload(
				rewriter, true, op.getLoc(), opName, lookUpUperandTypes);
		if (overload == nullptr)
			return mlir::failure();

		auto newCall = rewriter.replaceOpWithNewOp<mlir::rlc::CallOp>(
				op, overload, true, operandValues);
		auto infixSyntax = op.getInfixSyntax();
		if (infixSyntax != "")
			newCall->setAttr("infix_syntax", rewriter.getStringAttr(infixSyntax));

		return mlir::success();
	}

}	 // namespace mlir::rlc::detail
namespace mlir::rlc
{

	void pruneUnrechableBlocks(mlir::Region& op, mlir::IRRewriter& rewriter);

	inline void setInlineComment(mlir::Operation* op, llvm::StringRef comment)
	{
		op->setAttr("comment", mlir::StringAttr::get(op->getContext(), comment));
	}

	inline void setInlineComment(mlir::Operation* op, mlir::rlc::Comment comment)
	{
		if (comment == nullptr or comment.getText().empty())
			return;
		op->setAttr("comment", comment.getTextAttr());
		comment.erase();
	}

	inline llvm::StringRef getComment(mlir::Operation* op)
	{
		if (not op->hasAttr("comment"))
		{
			return "";
		}
		return mlir::cast<mlir::StringAttr>(op->getAttr("comment"));
	}
}	 // namespace mlir::rlc

namespace rlc
{
	using StatementTypes = std::variant<
			mlir::rlc::StatementList,
			mlir::rlc::ExpressionStatement,
			mlir::rlc::DeclarationStatement,
			mlir::rlc::IfStatement,
			mlir::rlc::ReturnStatement,
			mlir::rlc::WhileStatement,
			mlir::rlc::ActionStatement>;
}
